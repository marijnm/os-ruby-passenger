From 27894da4c7a5da30ef7ab4b03f914d1dec8531ac Mon Sep 17 00:00:00 2001
From: "Hongli Lai (Phusion)" <hongli@phusion.nl>
Date: Sun, 26 Aug 2012 14:27:39 +0200
Subject: [PATCH] Backport fix from
 https://svn.boost.org/trac/boost/ticket/6940 This allows passenger to build
 on Fedora 18/19.

---
 ext/boost/config/suffix.hpp        | 12 ++++++++++++
 ext/boost/src/pthread/thread.cpp   |  4 ++--
 ext/boost/src/pthread/timeconv.inl | 16 ++++++++--------
 ext/boost/thread/locks.hpp         |  6 +++---
 ext/boost/thread/xtime.hpp         |  4 ++--
 ext/common/ApplicationPool/Pool.h  |  2 +-
 7 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/ext/boost/config/suffix.hpp b/ext/boost/config/suffix.hpp
index 3408d22..6464f33 100644
--- a/ext/boost/config/suffix.hpp
+++ b/ext/boost/config/suffix.hpp
@@ -103,6 +103,18 @@
 #endif
 
 //
+// constexpr workarounds
+// 
+#if defined(BOOST_NO_CONSTEXPR)
+#define BOOST_CONSTEXPR
+#define BOOST_CONSTEXPR_OR_CONST const
+#else
+#define BOOST_CONSTEXPR constexpr
+#define BOOST_CONSTEXPR_OR_CONST constexpr
+#endif
+#define BOOST_STATIC_CONSTEXPR  static BOOST_CONSTEXPR_OR_CONST
+
+//
 // if there is no __int64 then there is no specialisation
 // for numeric_limits<__int64> either:
 //
diff --git a/ext/boost/src/pthread/thread.cpp b/ext/boost/src/pthread/thread.cpp
index b5a0572..f90cfcd 100644
--- a/ext/boost/src/pthread/thread.cpp
+++ b/ext/boost/src/pthread/thread.cpp
@@ -365,7 +365,7 @@
                     cond.timed_wait(lock, xt);
 #   endif
                     xtime cur;
-                    xtime_get(&cur, TIME_UTC);
+                    xtime_get(&cur, TIME_UTC_);
                     if (xtime_cmp(xt, cur) <= 0)
                         return;
                 }
@@ -380,7 +380,7 @@
             BOOST_VERIFY(!pthread_yield());
 #   else
             xtime xt;
-            xtime_get(&xt, TIME_UTC);
+            xtime_get(&xt, TIME_UTC_);
             sleep(xt);
 #   endif
         }
diff --git a/ext/boost/src/pthread/timeconv.inl b/ext/boost/src/pthread/timeconv.inl
index b75a135..7c07802 100644
--- a/ext/boost/src/pthread/timeconv.inl
+++ b/ext/boost/src/pthread/timeconv.inl
@@ -20,8 +20,8 @@ const int NANOSECONDS_PER_MICROSECOND = 1000;
 inline void to_time(int milliseconds, boost::xtime& xt)
 {
     int res = 0;
-    res = boost::xtime_get(&xt, boost::TIME_UTC);
-    BOOST_ASSERT(res == boost::TIME_UTC);
+    res = boost::xtime_get(&xt, boost::TIME_UTC_);
+    BOOST_ASSERT(res == boost::TIME_UTC_);
 
     xt.sec += (milliseconds / MILLISECONDS_PER_SECOND);
     xt.nsec += ((milliseconds % MILLISECONDS_PER_SECOND) *
@@ -57,8 +57,8 @@ inline void to_timespec_duration(const boost::xtime& xt, timespec& ts)
 {
     boost::xtime cur;
     int res = 0;
-    res = boost::xtime_get(&cur, boost::TIME_UTC);
-    BOOST_ASSERT(res == boost::TIME_UTC);
+    res = boost::xtime_get(&cur, boost::TIME_UTC_);
+    BOOST_ASSERT(res == boost::TIME_UTC_);
 
     if (boost::xtime_cmp(xt, cur) <= 0)
     {
@@ -88,8 +88,8 @@ inline void to_duration(boost::xtime xt, int& milliseconds)
 {
     boost::xtime cur;
     int res = 0;
-    res = boost::xtime_get(&cur, boost::TIME_UTC);
-    BOOST_ASSERT(res == boost::TIME_UTC);
+    res = boost::xtime_get(&cur, boost::TIME_UTC_);
+    BOOST_ASSERT(res == boost::TIME_UTC_);
 
     if (boost::xtime_cmp(xt, cur) <= 0)
         milliseconds = 0;
@@ -110,8 +110,8 @@ inline void to_microduration(boost::xtime xt, int& microseconds)
 {
     boost::xtime cur;
     int res = 0;
-    res = boost::xtime_get(&cur, boost::TIME_UTC);
-    BOOST_ASSERT(res == boost::TIME_UTC);
+    res = boost::xtime_get(&cur, boost::TIME_UTC_);
+    BOOST_ASSERT(res == boost::TIME_UTC_);
 
     if (boost::xtime_cmp(xt, cur) <= 0)
         microseconds = 0;
diff --git a/ext/boost/thread/locks.hpp b/ext/boost/thread/locks.hpp
index dd66a67..d77b145 100644
--- a/ext/boost/thread/locks.hpp
+++ b/ext/boost/thread/locks.hpp
@@ -164,9 +164,9 @@
     struct adopt_lock_t
     {};
     
-    const defer_lock_t defer_lock={};
-    const try_to_lock_t try_to_lock={};
-    const adopt_lock_t adopt_lock={};
+    BOOST_CONSTEXPR_OR_CONST defer_lock_t defer_lock={};
+    BOOST_CONSTEXPR_OR_CONST try_to_lock_t try_to_lock={};
+    BOOST_CONSTEXPR_OR_CONST adopt_lock_t adopt_lock={};
 
     template<typename Mutex>
     class shared_lock;
diff --git a/ext/boost/thread/xtime.hpp b/ext/boost/thread/xtime.hpp
index 7cc6272..f908298 100644
--- a/ext/boost/thread/xtime.hpp
+++ b/ext/boost/thread/xtime.hpp
@@ -20,7 +20,7 @@
 
 enum xtime_clock_types
 {
-    TIME_UTC=1
+    TIME_UTC_=1
 //    TIME_TAI,
 //    TIME_MONOTONIC,
 //    TIME_PROCESS,
@@ -68,7 +68,7 @@ inline xtime get_xtime(boost::system_time const& abs_time)
 
 inline int xtime_get(struct xtime* xtp, int clock_type)
 {
-    if (clock_type == TIME_UTC)
+    if (clock_type == TIME_UTC_)
     {
         *xtp=get_xtime(get_system_time());
         return clock_type;
diff --git a/ext/common/ApplicationPool/Pool.h b/ext/common/ApplicationPool/Pool.h
index 8c87ad5..d26529d 100644
--- a/ext/common/ApplicationPool/Pool.h
+++ b/ext/common/ApplicationPool/Pool.h
@@ -718,7 +718,7 @@ class Pool: public ApplicationPool::Interface {
 					}
 				} else {
 					xtime xt;
-					xtime_get(&xt, TIME_UTC);
+					xtime_get(&xt, TIME_UTC_);
 					xt.sec += maxIdleTime + 1;
 					if (cleanerThreadSleeper.timed_wait(l, xt)) {
 						// Condition was woken up.
-- 
1.8.1.6

