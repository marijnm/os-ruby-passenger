From c04590871ca0878d4d3ac1220c5a554b049056b4 Mon Sep 17 00:00:00 2001
From: "Hongli Lai (Phusion)" <hongli@phusion.nl>
Date: Tue, 1 Dec 2015 14:21:35 +0100
Subject: [PATCH] Fix a header collision vulnerability (CVE-2015-7519)

---
 ext/apache2/Hooks.cpp      | 23 +++++++++++++++++++++--
 ext/nginx/ContentHandler.c | 18 +++++++++++++++++-
 2 files changed, 38 insertions(+), 3 deletions(-)

diff --git a/ext/apache2/Hooks.cpp b/ext/apache2/Hooks.cpp
index 4c0dcd8..d7f1057 100644
--- a/ext/apache2/Hooks.cpp
+++ b/ext/apache2/Hooks.cpp
@@ -798,6 +798,16 @@ class Hooks {
 			apr_strnatcasecmp(headerName + 1, "ransfer-encoding") == 0;
 	}
 
+	bool contains_non_alphanumdash(const char *current) {
+		while (*current != '\0') {
+			if (!apr_isalnum(*current) && *current != '-') {
+				return false;
+			}
+			current++;
+		}
+		return true;
+	}
+
 	/**
 	 * Convert an HTTP header name to a CGI environment name.
 	 */
@@ -806,10 +816,12 @@ class Hooks {
 		char *current = result + sizeof("HTTP_") - 1;
 
 		while (*current != '\0') {
-			if (*current == '-') {
+			if (apr_isalnum(*current)) {
+				*current = apr_toupper(*current);
+			} else if (*current == '-') {
 				*current = '_';
 			} else {
-				*current = apr_toupper(*current);
+				return NULL;
 			}
 			current++;
 		}
@@ -958,11 +970,18 @@ class Hooks {
 			if (hdrs[i].key == NULL) {
 				continue;
 			}
+
+			if (!contains_non_alphanumdash(hdrs[i].key)) {
+				continue;
+			}
+
 			size_t keylen = strlen(hdrs[i].key);
 			// We only pass the Transfer-Encoding header if PassengerBufferUpload is disabled,
 			// so that the HelperAgent and the app knows that there is a request body despite
 			// there not being a Content-Length header.
 			if (!headerIsTransferEncoding(hdrs[i].key, keylen) || config->bufferUpload == DirConfig::DISABLED) {
+				// httpToEnv can never return NULL here because of the
+				// earlier contains_non_alphanumdash() check.
 				addHeader(output, httpToEnv(r->pool, hdrs[i].key, keylen), hdrs[i].val);
 			}
 		}
diff --git a/ext/nginx/ContentHandler.c b/ext/nginx/ContentHandler.c
index b1bde9e..29a4f2e 100644
--- a/ext/nginx/ContentHandler.c
+++ b/ext/nginx/ContentHandler.c
@@ -320,6 +320,18 @@ header_is_transfer_encoding(ngx_str_t *key)
         ngx_strncasecmp(key->data + 1, (u_char *) "ransfer-encodin", sizeof("ransfer-encodin") - 1) == 0;
 }
 
+static int
+header_contains_non_alphanumdash(ngx_str_t *key)
+{
+	unsigned int i;
+	for (i = 0; i < key->len; i++) {
+		u_char c = key->data[i];
+		if (!(c >= 'a' && c <= 'z') && !(c >= 'A' && c <= 'Z') && !(c == '-') && !(c >= '0' && c <= '9')) {
+			return 1;
+		}
+	}
+	return 0;
+}
 
 static ngx_int_t
 create_request(ngx_http_request_t *r)
@@ -490,7 +502,7 @@ create_request(ngx_http_request_t *r)
                 i = 0;
             }
 
-            if (!header_is_transfer_encoding(&header[i].key)) {
+            if (!header_is_transfer_encoding(&header[i].key) && !header_contains_non_alphanumdash(&header[i].key)) {
                 len += sizeof("HTTP_") - 1 + header[i].key.len + 1
                     + header[i].value.len + 1;
             }
@@ -674,6 +686,10 @@ create_request(ngx_http_request_t *r)
                 i = 0;
             }
 
+            if (header_contains_non_alphanumdash(&header[i].key)) {
+            	continue;
+            }
+
             if (header_is_transfer_encoding(&header[i].key)) {
                 continue;
             }
