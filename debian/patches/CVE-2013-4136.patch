Description: Fix for CVE-2013-4136: insecure tmp files usage
Origin: backport, https://github.com/phusion/passenger/commit/5483b3292cc2af1c83033eaaadec20dba4dcfd9b
 and https://github.com/phusion/passenger/commit/9dda49f4a3ebe9bafc48da1bd45799f30ce19566
Bug: https://code.google.com/p/phusion-passenger/issues/detail?id=910
Bug-Debian: http://bugs.debian.org/717176

--- a/ext/common/LoggingAgent/Main.cpp
+++ b/ext/common/LoggingAgent/Main.cpp
@@ -265,11 +265,6 @@
 		ev::sig sigtermWatcher(eventLoop);
 		ev::sig sigquitWatcher(eventLoop);
 		
-		if (feedbackFdAvailable()) {
-			feedbackFdWatcher.set<&feedbackFdBecameReadable>();
-			feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
-			writeArrayMessage(FEEDBACK_FD, "initialized", NULL);
-		}
 		sigintWatcher.set<&caughtExitSignal>();
 		sigintWatcher.start(SIGINT);
 		sigtermWatcher.set<&caughtExitSignal>();
@@ -281,6 +276,11 @@
 		/********** Initialized! Enter main loop... **********/
 		
 		P_DEBUG("Logging agent online, listening at " << socketAddress);
+		if (feedbackFdAvailable()) {
+			feedbackFdWatcher.set<&feedbackFdBecameReadable>();
+			feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
+			writeArrayMessage(FEEDBACK_FD, "initialized", NULL);
+		}
 		ev_loop(eventLoop, 0);
 		return exitCode;
 	} catch (const tracable_exception &e) {
--- a/ext/common/ServerInstanceDir.h
+++ b/ext/common/ServerInstanceDir.h
@@ -30,6 +30,7 @@
 #include <oxt/backtrace.hpp>
 
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <dirent.h>
 #include <unistd.h>
 #include <pwd.h>
@@ -38,6 +39,7 @@
 #include <cstring>
 #include <string>
 
+#include <Logging.h>
 #include "Exceptions.h"
 #include "Utils.h"
 #include "Utils/StrIntUtils.h"
@@ -47,6 +49,15 @@
 using namespace std;
 using namespace boost;
 
+/* TODO: I think we should move away from generation dirs in the future.
+ * That way we can become immune to existing-directory-in-tmp denial of
+ * service attacks. To achieve the same functionality as we do now, each
+ * server instance directory is tagged with the control process's PID
+ * and a creation timestamp. passenger-status should treat the server instance
+ * directory with the most recent creation timestamp as the one to query.
+ * For now, the current code does not lead to an exploit.
+ */
+
 class ServerInstanceDir: public noncopyable {
 public:
 	// Don't forget to update lib/phusion_passenger/admin_tools/server_instance.rb too.
@@ -217,7 +228,69 @@
 		 * rights though, because we want admin tools to be able to list the available
 		 * generations no matter what user they're running as.
 		 */
-		makeDirTree(path, "u=rwxs,g=rx,o=rx");
+		if (owner) {
+			switch (getFileType(path)) {
+			case FT_NONEXISTANT:
+				createDirectory(path);
+				break;
+			case FT_DIRECTORY:
+				verifyDirectoryPermissions(path);
+				break;
+			default:
+				throw RuntimeException("'" + path + "' already exists, and is not a directory");
+			}
+		} else if (getFileType(path) != FT_DIRECTORY) {
+			throw RuntimeException("Server instance directory '" + path +
+				"' does not exist");
+		}
+	}
+
+	void createDirectory(const string &path) const {
+		// We do not use makeDirTree() here. If an attacker creates a directory
+		// just before we do, then we want to abort because we want the directory
+		// to have specific permissions.
+		if (mkdir(path.c_str(), parseModeString("u=rwx,g=rx,o=rx")) == -1) {
+			int e = errno;
+			throw FileSystemException("Cannot create server instance directory '" +
+				path + "'", e, path);
+		}
+		// verifyDirectoryPermissions() checks for the owner/group so we must make
+		// sure the server instance directory has that owner/group, even when the
+		// parent directory has setgid on.
+		if (chown(path.c_str(), geteuid(), getegid()) == -1) {
+			int e = errno;
+			throw FileSystemException("Cannot change the permissions of the server "
+				"instance directory '" + path + "'", e, path);
+		}
+	}
+
+	/**
+	 * When reusing an existing server instance directory, check permissions
+	 * so that an attacker cannot pre-create a directory with too liberal
+	 * permissions.
+	 */
+	void verifyDirectoryPermissions(const string &path) {
+		TRACE_POINT();
+		struct stat buf;
+
+		if (stat(path.c_str(), &buf) == -1) {
+			int e = errno;
+			throw FileSystemException("Cannot stat() " + path, e, path);
+		} else if (buf.st_mode != (S_IFDIR | parseModeString("u=rwx,g=rx,o=rx"))) {
+			throw RuntimeException("Tried to reuse existing server instance directory " +
+				path + ", but it has wrong permissions");
+		} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {
+			/* The server instance directory is always created by the Watchdog. Its UID/GID never
+			 * changes because:
+			 * 1. Disabling user switching only lowers the privilege of the HelperAgent.
+			 * 2. For the UID/GID to change, the web server must be completely restarted
+			 *    (not just graceful reload) so that the control process can change its UID/GID.
+			 *    This causes the PID to change, so that an entirely new server instance
+			 *    directory is created.
+			 */
+			throw RuntimeException("Tried to reuse existing server instance directory " +
+				path + ", but it has wrong owner and group");
+		}
 	}
 	
 	bool isDirectory(const string &dir, struct dirent *entry) const {
--- a/test/cxx/ServerInstanceDirTest.cpp
+++ b/test/cxx/ServerInstanceDirTest.cpp
@@ -73,9 +73,11 @@
 	}
 	
 	TEST_METHOD(5) {
-		// The destructor doesnn't remove the server instance directory if it
+		// The destructor doesn't remove the server instance directory if it
 		// wasn't created with the ownership flag or if it's been detached.
 		string path, path2;
+		makeDirTree(parentDir + "/passenger-test.1234");
+		makeDirTree(parentDir + "/passenger-test.5678");
 		{
 			ServerInstanceDir dir(1234, parentDir, false);
 			ServerInstanceDir dir2(5678, parentDir);
